# 后端到前端消息集成系统

## 快速测试 🚀

### 方法1：在测试面板测试（推荐）

```bash
npm run dev
```

1. 浏览器打开后跳过开场动画
2. 点击右下角 **🧪 红色按钮**打开测试面板
3. **预设测试**：点击任意测试按钮执行预定义序列
4. **自定义测试**：点击"自定义测试 →"按钮，可以输入参数：
   - 移动单位到指定坐标 (ID, X, Z)
   - 旋转单位到指定方向 (ID, 方向)
   - 移除指定ID的单位
5. 按 **F12** 查看控制台输出

**预期输出**：
```
[TestPanel] 执行后端测试: test_sequence
[MessageQueue] 收到消息: {type_msg: "move_to", ...}
[Handler] move_to id=1, to=[3,3]
```

### 方法2：在3D场景测试

1. 浏览器打开后跳过开场动画
2. 点击右下角 **🧪 红色按钮**打开测试面板
3. 点击 **🎮 进入3D场景** 按钮
4. 进入3D场景，可以看到两个立方体（蓝色=ID:1，红色=ID:2）
5. 再次点击右下角测试面板按钮执行测试
6. 观察立方体的移动、旋转、状态指示器等效果

---

## 系统架构

### 消息流程

```
后端 MoonBit (send.mbt)
    ↓ broadcast
global_msg
    ↓ subscribe
前端 glue.js
    ↓ enqueue
messageQueue
    ↓ process
执行动画/UI更新
```

### 核心文件

**后端**：
- `main/game/send.mbt` - 14个消息API
- `main/game/test_send.mbt` - 9个测试函数 🆕
- `main/global_msg/global_msg.mbt` - 消息广播

**前端**：
- `src/messageQueue.js` - 消息队列（16个处理器）🆕
- `src/glue.js` - 前后端桥接
- `src/vue/TestPanel.vue` - 测试面板

---

## 支持的消息类型

### 单位操作
```moonbit
move_to(id, position)           // 移动单位
change_direction(id, direction) // 改变朝向
remove_unit(id)                 // 移除单位（淡出动画）
set_copper(copper, id, pos)     // 放置铜偶
set_enemy(enemy, id, pos)       // 放置敌人
```

### 状态显示
```moonbit
display_can_move(id, true)      // 显示绿圈
display_can_attack(id, true)    // 显示红圈
clear_state(id)                 // 清除状态
```

### 相机控制
```moonbit
animate_move(id)                // 聚焦到单位
animate_reset()                 // 复位视角
```

### 地图块
```moonbit
put_map_block(position)         // 放置地图块
set_move_block(position)        // 绿色块
set_attack_block(position)      // 红色块
clear_block(position)           // 清除块状态
```

### 游戏流程 🆕
```moonbit
handle_game_round_pass()        // 回合结束（清除地块，恢复铜偶状态）
```

---

## 🆕 回合结束机制

### 工作原理

当回合结束时，系统会自动：
1. **清除所有地块状态**：移动块（绿色）、攻击块（红色）、传输块
2. **恢复铜偶状态**：所有铜偶的 `can_move` 和 `can_attack` 恢复为 `true`
3. **更新视觉指示**：重新显示绿圈和红圈

### 触发方式

**前端触发**（游戏流程中）：
```javascript
// 发送回合结束消息到后端
await eventloop(JSON.stringify({
  type: "on_game_round_pass",
  content: {}
}))
```

**后端触发**（测试）：
```moonbit
// 在测试代码中调用
@game.handle_game_round_pass()
```

### 测试方法

在测试面板中：
- **后端测试** → 点击 "🔄 回合结束"
- **EventLoop测试** → 点击 "🔄 回合结束"

---

## 在游戏代码中使用

```moonbit
// 后端 MoonBit 代码
move_to(player_id, (5, 5))
display_can_move(player_id, true)
```

消息会**自动**通过 `global_msg` 发送到前端并执行动画。

---

## 集成到3D场景

在你的游戏场景组件中：

```javascript
import { messageQueue, info_subscribe } from '@/glue.js'

onMounted(() => {
  // 1. 设置场景上下文
  messageQueue.setSceneContext({
    scene,           // Three.js Scene
    camera,          // Camera
    controls,        // OrbitControls
    models,          // [{id, object, ...}, ...]
    gridCellSize: 1.0,
    focusState: {},
  })
  
  // 2. 订阅消息（可选，用于日志）
  info_subscribe((msg) => {
    console.log('收到后端消息:', msg)
  })
})
```

**确保模型有ID**：
```javascript
const model = {
  id: 1,  // 与后端ID对应
  object: gltfScene,
  // ...
}
```

---

## 添加新消息类型

### 1. 后端定义API

```moonbit
// main/game/send.mbt
pub fn unit_jump(id : Int) -> Unit {
  @global_msg.msg_info.broadcast({
    type_msg: "unit_jump",
    content: ({ "id": id } : Json).stringify(),
  })
}
```

### 2. 前端注册处理器

```javascript
// src/messageQueue.js - registerAllHandlers()
messageQueue.registerHandler('unit_jump', async (data, context) => {
  const { id } = data
  const model = findModelById(context.models, id)
  
  if (model?.object) {
    // 实现跳跃动画
    await jumpAnimation(model.object)
  }
})
```

### 3. 导出测试函数（可选）

```moonbit
// main/main/global.mbt
pub fn test_jump() -> Unit {
  @game.unit_jump(1)
}
```

